<settings>



  <ConnectionStrings>
    <!-- SQL Server (default - no provider attribute needed) -->
    <default><![CDATA[Data Source=.\s22;Initial Catalog=test;Integrated Security=True;TrustServerCertificate=True;]]></default>

    <!-- SQL Server with explicit provider -->
    <server2 provider="Microsoft.Data.SqlClient"><![CDATA[Data Source=.\s22;Initial Catalog=test;Integrated Security=True;TrustServerCertificate=True;]]></server2>

    <!-- SQL Server with explicit provider - just simulating different servers -->
    <server3 provider="Microsoft.Data.SqlClient"><![CDATA[Data Source=.\s22;Initial Catalog=test;Integrated Security=True;TrustServerCertificate=True;]]></server3>

    <!-- PostgreSQL -->
    <postgres provider="Npgsql"><![CDATA[Host=localhost;Port=5432;Database=mydb;Username=myuser;Password=mypass;]]></postgres>

    <!-- MySQL / MariaDB -->
    <mysql provider="MySqlConnector"><![CDATA[Server=localhost;Port=3306;Database=mydb;User=root;Password=mypass;SslMode=None;]]></mysql>

    <!-- SQLite (file-based) -->
    <sqlite provider="Microsoft.Data.Sqlite"><![CDATA[Data Source=mydb.db;]]></sqlite>

    <!-- SQLite (in-memory) -->
    <sqlite_memory provider="Microsoft.Data.Sqlite"><![CDATA[Data Source=:memory:;]]></sqlite_memory>

    <!-- Oracle -->
    <oracle provider="Oracle.ManagedDataAccess.Core"><![CDATA[Data Source=(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=localhost)(PORT=1521))(CONNECT_DATA=(SERVICE_NAME=ORCL)));User Id=myuser;Password=mypass;]]></oracle>

    <!-- Oracle (simplified EZ Connect format) -->
    <oracle_ez provider="Oracle.ManagedDataAccess.Core"><![CDATA[Data Source=localhost:1521/ORCL;User Id=myuser;Password=mypass;]]></oracle_ez>
  </ConnectionStrings>
  
  <additional_configurations>
    <path>config/sql.xml</path>
    <path>config/api_gateway.xml</path>
    <path>config/api_keys.xml</path>
    <path>config/file_management.xml</path>
    <path>config/regex.xml</path>
    <path>config/auth_providers.xml</path>
    <path>config/encryption_test.xml</path>
    <!--<path>config/test_auth_provider.xml</path>-->
    
    <!-- 
    Controls whether the application automatically restarts when configuration file paths are added or removed.
    - true: Application will automatically stop (allowing IIS/hosting environment to restart it)
    - false (default): Logs a warning, requires manual application pool recycle to apply path changes
    Note: Content changes within existing configuration files always reload automatically.
    -->
    <restart_on_path_changes>false</restart_on_path_changes>
  </additional_configurations>


  <!-- 
  Settings Encryption Configuration (Windows only - uses DPAPI)
  
  This section configures automatic encryption of sensitive configuration values.
  On first run, unencrypted values in the specified sections will be encrypted in-place.
  The application maintains decrypted values in memory for runtime use.
  
  Note: DPAPI encryption is machine-specific. Values encrypted on one machine
  cannot be decrypted on another. Re-deploy with unencrypted values when moving
  to a new server, and they will be automatically encrypted on first run.
  -->
  <settings_encryption>
    <!-- Prefix added to encrypted values (helps identify what's encrypted) -->
    <encryption_prefix>encrypted:</encryption_prefix>
    <data_protection_key_path>c:/temp/vault/keys/</data_protection_key_path>

    <!-- List of configuration sections/paths to encrypt -->
    <sections_to_encrypt>
      
      <!-- Encrypt all connection strings -->
      <section>secret_info</section>
      <section>nested_secret_data</section>
      <section>api_keys_collections:external_vendors</section>
      

      <!-- Encrypt specific auth provider sections (uncomment as needed) -->
      <!--<section>authorize:providers:azure_b2c</section>-->
      <!--<section>authorize:providers:google</section>-->

      <!-- Encrypt SFTP passwords -->
      <!--<section>file_management:sftp_file_store:site3:password</section>-->
      <!--<section>file_management:sftp_file_store:site4:password</section>-->
    </sections_to_encrypt>
  </settings_encryption>  
  
  
  <!-- passing the value in the below `debug_mode_header_value` 
  as a value to header `debug-mode` in your HTTP request will enable debug mode
  allowing you to see the SQL query errors returned by the database server
  in your HTTP response.
  -->
  <debug_mode_header_value>54321</debug_mode_header_value>
  
  <generic_error_message><![CDATA[An error occurred while processing your request.]]></generic_error_message>

  <!-- Default headers to ignore when routing API Gateway requests 
  (e.g., when you have a route in `api_gateway.xml` that routes requests to another API)
  This is important to strip headers like `Host` when routing requests to another API
  as it may cause issues with the target API TLS certificate validation.
  Or you may want to strip `x-api-key` header when routing requests to another API
  when the `x-api-key` is processed locally by this application and not needed by the target API.
  This value can be overridden in each route in `api_gateway.xml` by adding the `headers_to_exclude_from_routing` attribute to the `route` node
  -->
  <headers_to_exclude_from_routing>Host</headers_to_exclude_from_routing>

  <!--
  If 'true', the system will ignore certificate errors when routing requests to another API
  (e.g., when you have a route in `api_gateway.xml` that routes requests to another API)
  This is useful when the target API has a self-signed certificate or an expired certificate.
  This value can be overridden in each route in `api_gateway.xml` by adding the `ignore_certificate_errors` attribute to the `route` node
  -->
  <ignore_certificate_errors_when_routing>false</ignore_certificate_errors_when_routing>

  <!--
  Allows for passing a timeout value in seconds for the DB command execution
  -->
  <db_command_timeout>30</db_command_timeout>
  
  <!-- 
  `cache` can be specified here with similar structure to  `cache` structure on API nodes 
  and it will be applied to all APIs unless overridden at the API level.
  -->

  <max_payload_size_in_bytes>367001600</max_payload_size_in_bytes>



<!--
  if `cors` not defined in `settings` -> `queries` -> `query node name goes here` or in 
  `settings` -> `routes` -> `api gateway node name goes here`, 
  the system will look for a default cors configuration here, 
  and if not found here also (i.e., not defined, or left empty),
  it will default to allowing all origins (i.e., `*`)
  -->
  <cors>
    <!-- regex pattern for localhost or *.example.com -->
    <pattern><![CDATA[^(localhost|.*\.example\.com)$]]></pattern>

    <!-- 
        fallback_origin: default cors value if the caller's origin domain doesn't match the regex pattern above,
        this value will be used as the `Access-Control-Allow-Origin` header in the response.
        If the caller's origin domain matches the regex pattern above, 
        the CORS headers will be set to match the caller's origin domain.
        -->
    <fallback_origin><![CDATA[www.example.com]]></fallback_origin>
  </cors>


</settings>