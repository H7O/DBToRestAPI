<settings>
  <queries>

    <!-- Example API endpoint returning JSON -->
    <hello_world>
      <query>
        <![CDATA[
        
        declare @name nvarchar(500) = {{name}};


        if (@name is null or ltrim(rtrim(@name)) = '')
        begin
            set @name = 'world';
        end
        select 
        'hello ' + @name + '! Time now is ' + convert(nvarchar(50), getdate(), 121) as message_from_db;
        
        
        ]]>
      </query>
      <!--
      This is just an example of how you can define an API end-point that returns a JSON object.
      The query is a SQL query that returns a JSON object.
      The end-point path to this query is `/hello_world` (e.g., `http://localhost:5000/hello_world`).
      
      The example above shows how you can use parameters in your query. 
      The parameter `name` is passed in the query string or request body as JSON object.

      Precident of parameters if the same parameter is passed in multiple places is as follows (from highest to lowest):
      1. Request query string (if the parameter is passed in the query string, it will override any other parameter with the same name)
      2. Request route (if the parameter is passed in the route, it will override any other parameter with the same name)
      3. Request body (if the parameter is passed in the request body, it will override any other parameter with the same name)
      4. HTTP headers (if the parameter is passed in the HTTP headers, it is the least priority and will be used only if the parameter is not passed in the query string, route, or request body)
      
      all parameters are case-insensitive, so `name`, `Name`, and `NAME` are considered the same parameter.
      The default regex for parsing parameters (if not specified) is `(?<open_marker>\{\{)(?<param>.*?)?(?<close_marker>\}\})`
      
      Other examples in this sample sql.xml file should show you how to change the default regex for parsing each type of parameters.
      -->
    </hello_world>



    <!-- Contact creation endpoint -->
    <create_contact>
      <mandatory_parameters>name,phone</mandatory_parameters>
      <!-- 
      You can enforce mandatory parameters in your query by adding them in the `mandatory_parameters` node.
      Mandatory parameters are parameters that must be passed in the HTTP request.
      If any of the mandatory parameters are missing, the app will return an HTTP 400 error (bad request error).
      

      -->
      
      <!-- `<route>` node is optional, if you don't specify it, the query will be accessible by `create_contact` which is the name of the query node. -->
      <route>contacts</route>
      
      <verb>POST</verb>
      <!--  
      `<verb>` node is optional, if you don't specify it and you have only one unique route, the query will be accessible by any HTTP verb.
      if there are multiple routes with the same verb, the first one will be used.
      -->

      <!-- default value (if not specified) is `auto`, available options are `auto`, `single` and `array` -->
      <response_structure>single</response_structure>
      <!-- 
      `response_structure` is optional, if you don't specify it, the app defaults to `auto`.
       The possible values are:
       
      1- `array`: instructs the app to return an array of JSON objects for multiple rows response with the following rules:
        a) if the query returned a single row, that row is set to be returned as a json object inside an array
        b) if the query returned multiple rows, the app will return an array of JSON objects with the following structure:
          [
            {
              "id": 1,
              "name": "John",
              "phone": "1234567890"
            },
            {
              "id": 2,
              "name": "Jane",
              "phone": "0987654321"
            }
          ]
        
      2- `single`: instructs the app to return a single JSON object of the first row returned by the query and not iterate over the rest of the rows.
        however, if `count_query` node is specified, the app then is set to return a count structure as per the below structured
        response format but has only the first row returned by the query (i.e., not iterate over the rest of the rows)
      
      3- `auto`: for auto response format (single if single row, array if multiple rows)
      
      **Note**: if `count_query` is specified, the `response_structure` is then ignored as the app 
      is expected to always return a count structure as per the below structured response format:
          {
            "count": 1,
            "data": [
              {
                "id": 1,
                "name": "John",
                "phone": "1234567890"
              }
            ]
          }


      -->
      
      

      <!-- success_status_code is optional, if you don't specify it, the app will return 200 OK -->
      <success_status_code>201</success_status_code>

      <query>
      <![CDATA[
        declare @name nvarchar(500) = {{name}};
        declare @phone nvarchar(100) = {{phone}};
        declare @active bit = {{active}};
      
        -- check if the contact already exists
      
        declare @existing_contact table 
        (
            id UNIQUEIDENTIFIER,
            name nvarchar(500),
            phone nvarchar(100)
        );
        insert into @existing_contact select top 1 id, name, phone from [contacts] where name = @name and phone = @phone;
      
        declare @error_msg nvarchar(500);
      
        -- return an http 409 error (conflict error) if the contact already exists
      
        if ((select count(*) from [contacts] where name = @name and phone = @phone) > 0)
        begin 
            set @error_msg = 'Contact with name ' + @name + ' and phone ' + @phone + ' already exists';
            -- to return http error code `409 Conflict` throw 50409 and the app will return 409.
            -- same for other http error codes, e.g. 404, 500, etc. Just throw 50404, 50500, etc.
            throw 50409, @error_msg, 1;
            return;
        end
        if (@active is null)
        begin
            set @active = 1;
        end
      
      -- insert new contact, and return it back to the http client
      insert into [contacts] (id, name, phone, active) 
      output inserted.id, inserted.name, inserted.phone, inserted.active
      values (newid(), @name, @phone, @active)
    ]]>
      </query>

      
    </create_contact>




    <!-- Contact update endpoint -->
    <update_contact>
      <route>contacts/{{id}}</route>
      <verb>PUT</verb>
      
      <mandatory_parameters>id,name,phone</mandatory_parameters>

      <connection_string_name>server2</connection_string_name>
      <!-- 
      connection_string_name tag is optional, 
      the app is designed to pickup the `default` connection string you define in 
      /config/settings.xml under `ConnectionStrings` node if you haven't set one here.
      However, if you need to access a different database for a specific query,
      you can set a different connection string name here, given that you've defined it in /config/settings.xml
      under `ConnectionStrings` node.
      The below connection string name is added here just to show you how you can
      choose a different connection string name.
      -->


      <query>
      <![CDATA[

      -- update contact
      declare @id UNIQUEIDENTIFIER = {{id}};
      declare @name nvarchar(500) = {{name}};
      declare @phone nvarchar(100) = {{phone}};
      
      -- check if contact exists
      
      declare @error_msg nvarchar(500);
      
      -- return an http 404 error (not found error) if the contact does not exist
      
      if ((select count(*) from [contacts] where id = @id) < 1)
      begin 
          set @error_msg = 'Contact with id ' + cast(@id as nvarchar(50)) + ' does not exist';
          -- to return http error code `404 Not found` throw 50404 and the app will return 404.
          throw 50404, @error_msg, 1;
          return;
      end
      
      -- update the contact, and return it back to the http client

      update [contacts] 
      set 
            [name] = @name, 
            phone = @phone 
      output 
        inserted.id, 
        inserted.name, 
        inserted.phone
      where 
        id = @id;      
      
      ]]>
      </query>
    </update_contact>


    <!-- Contact activation/deactivation endpoint -->
    <activate_deactivate_contact>
      <connection_string_name>server2</connection_string_name>
      <route>contacts/{{id}}/{{status_action}}</route>
      <verb>PUT</verb>
      <mandatory_parameters>id</mandatory_parameters>
      
      <query>
      <![CDATA[

      -- update contact
      declare @id UNIQUEIDENTIFIER = {{id}};
      -- status_action can be either `activate` or `deactivate`
      declare @status_action nvarchar(50) = {{status_action}};

      declare @error_msg nvarchar(500);

      if (@status_action is null or @status_action = ''
      or @status_action not in ('activate', 'deactivate'))
      begin
        set @error_msg = 'Invalid status action';
        throw 50400, @error_msg, 1;
        return;
      end
        
      -- check if contact exists
      
      -- return an http 404 error (not found error) if the contact does not exist
      
      if ((select count(*) from [contacts] where id = @id) < 1)
      begin 
          set @error_msg = 'Contact with id ' + cast(@id as nvarchar(50)) + ' does not exist';
          -- to return http error code `404 Not found` throw 50404 and the app will return 404.
          throw 50404, @error_msg, 1;
          return;
      end
      
      -- update the contact, and return it back to the http client

      declare @status_bit bit = case when @status_action = 'activate' then 1 else 0 end;

      update [contacts] 
      set 
            [active] = @status_bit
      output 
        inserted.id, 
        inserted.name, 
        inserted.phone,
        case when inserted.active = 1 then 'active' else 'inactive' end as status
      where 
        id = @id;      
      ]]>
      </query>
    </activate_deactivate_contact>


    <!-- Contact search endpoint -->
    <search_contacts>
      <route>contacts</route>
      <verb>GET</verb>
      <query>
        <![CDATA[
        declare @name nvarchar(500) = {{name}};
        declare @phone nvarchar(100) = {{phone}};
        declare @take int = {{take}};
        declare @skip int = {{skip}};
        declare @sort_by nvarchar(50) = {{sort_by}};
        declare @sort_order nvarchar(10) = {{sort_order}};

        if (@sort_by is null or @sort_by = '')
        begin
            set @sort_by = 'name';
        end

        -- default take to 100 if not specified
        if (@take is null or @take < 1)
        begin
            set @take = 100;
        end
        -- make sure max take doesn't exceed 1000
        if (@take > 1000)
        begin
            set @take = 1000;
        end
        -- default skip to 0 if not specified
        if (@skip is null or @skip < 0)
        begin
            set @skip = 0;
        end
        
        -- validate and default sort parameters (no need for sort by `id` if `id` is GUID, unless your `id` is an incrumental number)
        -- you can also add by create date, update date, etc. but for the purpose of this example, we'll only sort by `name` and `phone`
        if (@sort_by is null or @sort_by not in ('name', 'phone'))
        begin
            set @sort_by = 'name';
        end
        
        if (@sort_order is null or @sort_order not in ('asc', 'desc'))
        begin
            set @sort_order = 'asc';
        end


      select * from [contacts] 
        where 
          (@name is null or [name] like '%' +  @name + '%')
          and (@phone is null or [phone] like '%' +  @phone + '%')
        order by 
          case when @sort_by = 'name' and @sort_order = 'asc' then [name] end asc,
          case when @sort_by = 'name' and @sort_order = 'desc' then [name] end desc,
          case when @sort_by = 'phone' and @sort_order = 'asc' then [phone] end asc,
          case when @sort_by = 'phone' and @sort_order = 'desc' then [phone] end desc
        offset @skip rows
        fetch next @take rows only;        
        
        ]]>
      </query>
      <count_query>
        <![CDATA[
        declare @name nvarchar(500) = {{name}};
        declare @phone nvarchar(100) = {{phone}};
        select count(*) from [contacts] 
        where 
          (@name is null or [name] like '%' +  @name + '%')
          and (@phone is null or [phone] like '%' +  @phone + '%');
        
        ]]>
      </count_query>
      <!-- 
      Count Query Configuration:
      count query is optional, if you don't specify it, 
      the app will not return the total count of the results 
      (total as in without pagination applied) 
      -->
    </search_contacts>


    <!-- Contact deletion endpoint -->
    <delete_contact>
      <route>contacts/{{id}}</route>
      <verb>DELETE</verb>
      <mandatory_parameters>id</mandatory_parameters>
      <query>

        <![CDATA[
        declare @id UNIQUEIDENTIFIER = {{id}};
        -- check if contact exists
        declare @error_msg nvarchar(500);
        -- return an http 404 error (not found error) if the contact does not exist
        if ((select count(*) from [contacts] where id = @id) < 1)
        begin 
            set @error_msg = 'Contact with id ' + cast(@id as nvarchar(50)) + ' does not exist';
            -- to return http error code `404 Not found` throw 50404 and the app will return 404.
            throw 50404, @error_msg, 1;
            return;
        end
        -- delete the contact
        delete from [contacts] 
        OUTPUT DELETED.id, DELETED.name, DELETED.phone, DELETED.active
        where id = @id;
        
        ]]>
      </query>
    </delete_contact>



    <!-- Contact search without count endpoint -->
    <search_contacts_without_count>
      <route>contacts_without_count</route>
      <verb>GET</verb>

      <!-- default value (if not specified) is `auto`, available options are `auto`, `single` and `array` -->
      <response_structure>array</response_structure>
      <!-- 
      `response_structure` is optional, if you don't specify it, the app defaults to `auto`.
       The possible values are:
       
      1- `array`: instructs the app to return an array of JSON objects for multiple rows response with the following rules:
        a) if the query returned a single row, that row is set to be returned as a json object inside an array
        b) if the query returned multiple rows, the app will return an array of JSON objects with the following structure:
          [
            {
              "id": 1,
              "name": "John",
              "phone": "1234567890",
              "active": 1
            },
            {
              "id": 2,
              "name": "Jane",
              "phone": "0987654321",
              "active": 1
            }
          ]
        
      2- `single`: instructs the app to return a single JSON object of the first row returned by the query and not iterate over the rest of the rows.
        however, if `count_query` node is specified, the app then is set to return a count structure smiliar to the ones we saw in `search_contacts`query
      
      3- `auto`: for auto response format (single if single row, array if multiple rows)
      
      **Note**: if `count_query` is specified, the `response_structure` is then ignored as the app 
      is expected to always return a count structure as per the below structured response format:
          {
            "count": 2,
            "data": [
              {
                "id": 1,
                "name": "John",
                "phone": "1234567890",
                "active": 1
              },
              {
                "id": 2,
                "name": "Jane",
                "phone": "0987654321",
                "active": 1
              }
            ]
          }


      -->      
      
      
      
      <query>
        <![CDATA[
        declare @name nvarchar(500) = {{name}};
        declare @phone nvarchar(100) = {{phone}};
        declare @take int = {{take}};
        declare @skip int = {{skip}};
        declare @sort_by nvarchar(50) = {{sort_by}};
        declare @sort_order nvarchar(10) = {{sort_order}};

        if (@sort_by is null or @sort_by = '')
        begin
            set @sort_by = 'name';
        end

        -- default take to 100 if not specified
        if (@take is null or @take < 1)
        begin
            set @take = 100;
        end
        -- make sure max take doesn't exceed 1000
        if (@take > 1000)
        begin
            set @take = 1000;
        end
        -- default skip to 0 if not specified
        if (@skip is null or @skip < 0)
        begin
            set @skip = 0;
        end
        
        -- validate and default sort parameters (no need for sort by `id` if `id` is GUID, unless your `id` is an incrumental number)
        -- you can also add by create date, update date, etc. but for the purpose of this example, we'll only sort by `name` and `phone`
        if (@sort_by is null or @sort_by not in ('name', 'phone'))
        begin
            set @sort_by = 'name';
        end
        
        if (@sort_order is null or @sort_order not in ('asc', 'desc'))
        begin
            set @sort_order = 'asc';
        end


      select * from [contacts] 
        where 
          (@name is null or [name] like '%' +  @name + '%')
          and (@phone is null or [phone] like '%' +  @phone + '%')
        order by 
          case when @sort_by = 'name' and @sort_order = 'asc' then [name] end asc,
          case when @sort_by = 'name' and @sort_order = 'desc' then [name] end desc,
          case when @sort_by = 'phone' and @sort_order = 'asc' then [phone] end asc,
          case when @sort_by = 'phone' and @sort_order = 'desc' then [phone] end desc
        offset @skip rows
        fetch next @take rows only;        
        
        ]]>
      </query>

    </search_contacts_without_count>    
    
    
    


    <!-- Protected endpoint with local API keys (for global keys, use global_api_keys.xml) -->
    <hello_world_protected>
      <api_keys_collections>external_vendors, internal_solutions</api_keys_collections>
      <!-- 
      API Key Configuration:
      you can define per query api keys collection, each collection references a set of api keys defined in /config/api_keys_collections.xml 
      if you don't specify it, the query will be publically accessible.
      -->
      <query>
        <![CDATA[
        declare @name nvarchar(500) = {{name}};
        
        if (@name is null or ltrim(rtrim(@name)) = '')
        begin
            set @name = 'world';
        end
        select 'hello ' + @name + '!' as message_from_db;
        ]]>
      </query>
    </hello_world_protected>


    <!-- Custom variable delimiters example -->
    <hello_world_using_pipes_as_var_delimiters>
      <json_variables_pattern><![CDATA[(?<open_marker>\|\|)(?<param>.*?)?(?<close_marker>\|\|)]]></json_variables_pattern>
      <!-- 
      Variable Delimiter Configuration:
      this is to showcase how you can override the default 
      variable delimiters regex for each query
      -->
      <query>
        <![CDATA[
        declare @name nvarchar(500) = ||name||;
        
        if (@name is null or @name = '')
        begin
            set @name = 'world';
        end
        select 'hello ' + @name + '!' as message_from_db;
        ]]>
      </query>
    </hello_world_using_pipes_as_var_delimiters>



    <!-- Caching example -->
    <hello_world_with_cache>
      <cache>
        <memory>
          <duration_in_milliseconds>20000</duration_in_milliseconds>
          <invalidators>name</invalidators>
        </memory>
      </cache>
      <query>
        <![CDATA[
        
        declare @name nvarchar(500) = {{name}};


        if (@name is null or ltrim(rtrim(@name)) = '')
        begin
            set @name = 'world';
        end
        select 'hello ' + @name + '! Time now is ' + convert(nvarchar(50), getdate(), 121) as message_from_db;
        
        
        ]]>
      </query>


    </hello_world_with_cache>


    <!-- Nested JSON example -->
    <nested_json>
      <query>
        <![CDATA[
              SELECT
                  name,
                  (
                      SELECT phone
                      FROM contacts c2
                      WHERE c2.name = c1.name AND c2.active = 1
                      FOR JSON PATH
                  ) AS {type{json{phones}}},
                  1 AS active
              FROM contacts c1
              WHERE c1.active = 1
              GROUP BY name;        
        ]]>
      </query>
      <!--
      JSON Type Decorator:
      The {type{json{field_name}}} decorator tells the engine to parse the returned JSON string 
      and embed it as a proper nested JSON object instead of an escaped string.
      
      WITHOUT `{type{json{phones}}}` decorator, the returned result would look like this:
      
      ```json
      [
          {
              "name": "Bob Johnson",
              "phones": "[{\"phone\":\"+1-555-0103\"},{\"phone\":\"+1-555-0103\"}]",
              "active": 1
          },
          {
              "name": "Jane Smith",
              "phones": "[{\"phone\":\"+1-555-0102\"},{\"phone\":\"+1-555-0102\"}]",
              "active": 1
          },
          {
              "name": "John Doe",
              "phones": "[{\"phone\":\"+1-555-0101\"},{\"phone\":\"+1-555-0101\"}]",
              "active": 1
          }
      ]      
      ```

      WITH `{type{json{phones}}}` decorator, the returned result would look like this:

      ```json
      [
          {
              "name": "Bob Johnson",
              "phones": [
                  {
                      "phone": "+1-555-0103"
                  },
                  {
                      "phone": "+1-555-0103"
                  }
              ],
              "active": 1
          },
          {
              "name": "Jane Smith",
              "phones": [
                  {
                      "phone": "+1-555-0102"
                  },
                  {
                      "phone": "+1-555-0102"
                  }
              ],
              "active": 1
          },
          {
              "name": "John Doe",
              "phones": [
                  {
                      "phone": "+1-555-0101"
                  },
                  {
                      "phone": "+1-555-0101"
                  }
              ],
              "active": 1
          }
      ]      
      ```
      
      This makes your API responses much cleaner and eliminates the need for 
      additional JSON.parse() calls on the client side.
      -->
    </nested_json>



    <test_json>
      <query>
        <![CDATA[
        declare @json_data nvarchar(max) = {{json_data}};
          select 'john' as name,
          @json_data as {type{json{received_json_data}}};
        ]]>
      </query>
    </test_json>
    <test_json2>
      <query>
        <![CDATA[
          SELECT 
            'John' as [name],
            (select * from (values 
		        ('55555', 'Mobile'), 
		        ('44444', 'Work')) 
          as t (number, [type]) for json path) AS {type{json{phones}}};
        ]]>
      </query>
    </test_json2>


    <!-- Contact creation (with files) endpoint -->
    <create_contact_with_files>
      <mandatory_parameters>name,phone</mandatory_parameters>

      <route>v2/contacts</route>

      <verb>POST</verb>


      <file_management>
        <!-- file stores could be a local store or an sftp remote store, their individual
        settings correspondes to the ones defined in your file_stores.xml file under
        `settings` -> `file_management` node
         -->
        <stores>site1, site2, site3, site4</stores>


        <!-- `permitted_file_extensions` is optional, if not defined, 
        if will first check if there is a `permitted_file_extensions` tag defined
        under `settings` -> `file_management` -->
        <permitted_file_extensions>.txt,.pdf,.docx,.xlsx,.png,.jpg,.jpeg</permitted_file_extensions>

        <!-- `max_file_size_in_bytes` is optional, if not defined,
        it will first check if there is a `max_file_size_in_bytes` tag defined
        under `settings` -> `file_management` or default to 300MB if not defined -->
        <max_file_size_in_bytes>10485760</max_file_size_in_bytes>
        <!-- 10 MB -->

        <!-- the below two field would fallback on `file_management` settings if not defined here -->
        <filename_field_in_payload>file_name</filename_field_in_payload>
        <base64_content_field_in_payload>base64_content</base64_content_field_in_payload>


        <!-- `files_json_field_or_form_field_name` tells the application to look for files metadata in 
        the specified json property (for application/json content type) or form field (for multipart/form-data content type)
        if not defined, the system will fall back on the same tag under `settings` -> `file_management`
        -->
        <files_json_field_or_form_field_name>files</files_json_field_or_form_field_name>

        <pass_files_content_to_query>false</pass_files_content_to_query>
<!-- `pass_files_content_to_query` controls whether the uploaded files content is passed to the SQL query
        when set to true, the files content will be included in the query.
        when set to false, only the files metadata will be passed to the query.
        if not defined, the system will check if this tag is defined under `settings` -> `file_management`, if not, it will default to false.
        
        
        the caller needs to pass json metadata for each file being uploaded as follows:
        
        ```json
        [
            {
              "id": "optional GUID for the file, if not provided, the engine will generate one",
              "name": "example.txt",
              "description": "This is an example text file", // optional custom field
              "base64_content": "SGVsbG8gd29ybGQh...", // only if `pass_files_content_to_query` is set to true
              // other custom fields can be added here
            },
            ...
        ]
        ```


        
        The system then adds extra fields to the structure sent by the caller and pass it to the query.
        
        below is the structure of the file metadata (and content if that option is enabled) that gets passed to the sql query:
        
        ```json
        [
            {
              "id": "generated GUID for the file by the engine, unless passed by the caller",
              "name": "example.txt",
              "relative_path": "2025/Oct/22/<the-guid-referenced-in-the-id-field>/example.txt", // relative path structure is defined in settings
              "extension": ".txt",
              "size": 1234,
              "base64_content": "SGVsbG8gd29ybGQh..." // only if `pass_files_content_to_query` is set to true 
            },
            ...
        ]
        ```
        
        `id` is a GUID generated by the engine for each uploaded file, unless the caller provides it during upload.
        `relative_path` is the base path of the file store + `file_management:relative_file_path_structure`
          e.g., if the base path is `c:\filestore` and the `relative_file_path_structure` is `{date{yyyy}}\{date{MMM}}\{date{dd}}\{{guid}}\{file{name}}`
          then the full path of the file will be `c:\filestore\2025\Oct\22\<guid-goes-here>\example.txt`
        
        the caller can enrich the file metadata during upload by providing additional fields such as `description` (or any other custom fields)
        
        
        The caller can send the files and its metadata in either `application/json` or `multipart/form-data` content type.
        
        1- For `application/json` content type, the caller needs to send a json payload having both the metadata and content 
        in a json property of their choosing:
        e.g., if the caller chooses to send the files in a json property named `files`,
        
        ```json
        {
            "name": "John",
            "age": 30,
                // other json payload fields can go here
            "files": [
                {
                  "id": "optional GUID for the file, if not provided, the engine will generate one",
                  "name": "example.txt",
                  "description": "This is an example text file",
                  "base64_content": "SGVsbG8gd29ybGQh..."
                  // other custom fields can be added here
                },
                ...
            ]
        }
        ```
        
        Only the `name` and `base64_content` fields are mandatory for each file being uploaded.
        
        Receiving the metadata (and the base64 content if that option is enabled) in sql query in this case can be done via `{fs{json_metadata_field_name}}`
        which in our example is `{fs{files}}`
        
        
        2- For `multipart/form-data` content type, the caller can upload files as multipart files
          and choose a form field to send the files metadata in as a json payload.
          for example, if the caller chooses to send the files metadata in a form field named `files`
          the sql query can access the files metadata (along with base64 content if that option is enabled)  via `{fs{files}}`
        
        -->

        <max_number_of_files>2</max_number_of_files>
        <!-- max_number_of_files is optional, if not defined, it will check if it's defined in the file store settings,
        if not, it will default to 10 files per request
          -->
      </file_management>



      <success_status_code>201</success_status_code>

      <query>
        <![CDATA[
        use [test]

        declare @name nvarchar(500) = {{name}};
        declare @phone nvarchar(100) = {{phone}};
        declare @active bit = {{active}};
        declare @files_json nvarchar(max) = {{files}};
        declare @description nvarchar(1000) = {{description}};
      
        -- check if the contact already exists
      
        declare @existing_contact table 
        (
            id UNIQUEIDENTIFIER,
            name nvarchar(500),
            phone nvarchar(100)
        );
        insert into @existing_contact select top 1 id, name, phone from [contacts] where name = @name and phone = @phone;
      
        declare @error_msg nvarchar(500);
      
        -- return an http 409 error (conflict error) if the contact already exists
      
        if ((select count(*) from [contacts] where name = @name and phone = @phone) > 0)
        begin 
            set @error_msg = 'Contact with name ' + @name + ' and phone ' + @phone + ' already exists';
            -- to return http error code `409 Conflict` throw 50409 and the app will return 409.
            -- same for other http error codes, e.g. 404, 500, etc. Just throw 50404, 50500, etc.
            throw 50409, @error_msg, 1;
            return;
        end
        if (@active is null)
        begin
            set @active = 1;
        end
      
      -- insert new contact, and return it back to the http client
      
      -- table to hold the output of the inserted contact
      
      declare @new_contact table 
      (
          id UNIQUEIDENTIFIER,
          name nvarchar(500),
          phone nvarchar(100),
          active bit
      );

      
      begin transaction;
      begin try

       -- todo: insert to database but also hold the result in @new_contact
        insert into [contacts] (id, name, phone, active) 
        output inserted.id, inserted.name, inserted.phone, inserted.active
        into @new_contact (id, name, phone, active)
        values (newid(), @name, @phone, @active)
        
      


        -- 1) parse @files_json (it should have the following fields into @files table:
        -- `id`: guid (generated by the engine unless provided by the caller)
        -- `file_name` (e.g., test.txt)
        -- `relative_path` (e.g., `/2025/Oct/28/<some guid>/test.txt`) - generated by the engine
        -- `description` (e.g., `drivers license`)
        


        -- Declare table to hold parsed file metadata
        declare @files table (
            id UNIQUEIDENTIFIER,
            contact_id UNIQUEIDENTIFIER,
            file_name nvarchar(255),
            relative_path nvarchar(1000),
            description nvarchar(1000)
        );
        
        -- 2) insert the @files table into `files` db table that has the exact above fields
        -- Parse JSON into @files
        insert into @files (id, file_name, relative_path, description)
        select 
            JSON_VALUE(value, '$.id'),
            -- (select id from @new_contact) as contact_id, -- you can setcontact_id here or in the next step
            JSON_VALUE(value, '$.file_name'),
            JSON_VALUE(value, '$.relative_path'),
            JSON_VALUE(value, '$.description')
        from OPENJSON(@files_json);
        

        -- 3) update the `contact_id` field in the @files table with the newly created contact id 
        update f
        set contact_id = nc.id
        from @files f
        cross join @new_contact nc;
        
        
        -- 4) insert the @files table into `files` db table that has the exact above fields
        
        insert into [files] (id, contact_id, file_name, relative_path, description)
        select 
            id,
            contact_id,
            file_name,
            relative_path,
            description
        from
            @files


        commit transaction;
      end try
      begin catch
        rollback transaction;
        throw;
      end catch

    -- 5) after committing return the @new_contact with extra field called `files` that has the @files table content 
    --    as a json string (json array)
    
    -- debug : delete the entries (so you could keep rerunning the test)
    delete from [contacts] where id in (select id from @new_contact);
    delete from [files] where contact_id in (select id from @new_contact);

    select 
        nc.id,
        nc.name,
        nc.phone,
        nc.active,
        (
            select id, file_name, relative_path, description
            from @files
            for json path
        ) as {type{json{files}}}
    from @new_contact nc;

    ]]>
      </query>


    </create_contact_with_files>

    
    
    <download_document_example>
      <route>documents/{{id}}</route>
      <verb>get</verb>
      <!-- 
      setting the `response_structure` to file indicates to the app that 
      the response is going to be a file download response
      -->
      <response_structure>file</response_structure>

      <mandatory_parameters>id</mandatory_parameters>
      
      <file_management>
        <!-- 
        if `response_structure` is set to `file`, the app will return the file as a download response
        the query in this case should return a single row with the following fields:
        - `file_name`: the name of the file to be downloaded (e.g., document.pdf), 
            and if not returned (or returnd eempty) the app will attempt to pickup the name from the `relative_path` field.
            and if both are not available, it will default to `downloaded_file`
        - `base64_content` (optional): the base64 content of the file to be downloaded if the file is stored in the database
        - `relative_path` (optional): the relative path of the file in the file store if the file is stored in a file store (e.g., local file store or sftp store)
        - `content_type` (optional): the mime content type of the file (e.g., application/pdf, image/png, text/plain, etc..)
        if not provided, the app will attempt to infer the mime typefrom the file extension, and if not possible, it will default to `application/octet-stream`
        - `http` (optional): if provided, the app will route the download request to the provided http/s url to fetch the file content from there
        
        Note: if multiple fields are provided (e.g., both `base64_content`, `relative_path` and `http`),
        the app will prioritize the file content source in the following order:
        1- `base64_content`
        2- `relative_path`
        3- `http`
        
        The query also will receive from the app the following variable:
        - `{fs{store}}`: which holds the name of the file store where the file is located (e.g., `local1`, `sftp_backup`, `site1`, etc..)
        - `{fs{base_path}}`: which holds the base path of the file store where the file is located 
        (e.g., `c:/filestore` for local store, or `/var/filestore`, `/home/user/filestore`, etc.. for sftp stores)
        both variables above aren't that useful in majority of the cases as the app handles the file retrieval automatically
        and all what it needs is just the `relative_path` to locate the file in the store. But its there for advanced use cases
        where you might need to build the full path yourself in the query for logging or other purposes.
        - any parameters passed in the query string, json payload, form data, headers, route info, etc.. (similar to other examples above) 
        can be accessed via {{param_name}} notation
        -->

        <store>site3</store>
        <!-- 
        notice in the upload example we had the node `stores` to specify multiple stores,
        however for download, its expected to have a single store only as the file is expected
        to be picked up from a single store only despite that you might have uploaded it to multiple stores.
        just keep in mind that the store specified here should match one of the stores used during upload.
        -->

      </file_management>

      <query>
        <![CDATA[

          declare @id uniqueidentifier = {{id}};
          
          declare @file_record table
          (
              id uniqueidentifier,
              file_name nvarchar(255),
              base64_content nvarchar(max),
              relative_path nvarchar(1000),
              content_type nvarchar(100)
          );
          
          -- select top 1 from `files` table into @file_record
          
          insert into 
          @file_record (id, file_name, base64_content, relative_path)
          select top 1 
              id,
              file_name,
              null as base64_content, -- assuming file is stored in file store
              relative_path
          from 
            files
          where id = @id;
          -- throw 50404 (which translates to http 404) if no record found with a message indicating that
          if ((select count(*) from @file_record) = 0)
          begin
              declare @err nvarchar(200);
              set @err = 'No document found with id ' + convert(nvarchar(50), @id);
              throw 50404, @err, 1;
              return;
          end
          
          -- else return the file record
          select 
              file_name,
              -- base64_content,
              relative_path
              
          from @file_record
          
        ]]>
      </query>
      


    </download_document_example>

    <hello_world_cors_example>
      <!-- 
      if `cors` not defined here, the system will look for a default cors configuration
      in main settings under files (e.g., settings.xml or cors_settings.xml, etc..) 
      under `settings` node, and if not found there also, 
      it will default to allowing all origins (i.e., `*`)
      -->
      <cors>
        <!-- regex pattern for localhost or *.example.com -->
        <pattern><![CDATA[^(localhost|.*\.example\.com)$]]></pattern>
        
        <!-- 
        fallback_origin: default cors value if the caller's origin domain doesn't match the regex pattern above,
        or the caller never set the `Origin` header in the request.
        This value will be used as the `Access-Control-Allow-Origin` header in the response.
        And if the caller's origin domain matches the regex pattern above, 
        the CORS headers will be set to match the caller's origin header.
        -->
        <fallback_origin><![CDATA[www.example.com]]></fallback_origin>
        <!-- if any of the settings in cors section here is not defined (or the whole section of `cors` is not defined)
        , the app will attempt to find if there is global `cors` section that have the same settings under `settings` node
        so if `fallback_origin` is not defined here, it will look for it in the global cors settings, 
        and if it's not defined there also, it will default to `*` (allow all origins).
        And if `pattern` is not defined here, it will look for it in the global cors settings,
        and if it's not defined there also, it will default to `fallback_origin` if `fallback_origin` is defined (here or globally) or `*` if not defined anywhere.
        if the caller doesn't send the `Origin` header in the request, the `fallback_origin` value will be used as the `Access-Control-Allow-Origin` header in the response.
        and if the `fallback_origin` is not defined anywhere (here or globally), it will default to `*` (allow all origins).
        -->
        
        <!--
        also there are other optional cors settings that can be defined here or globally such as:
        <max_age>3600</max_age>
        <allow_credentials>true</allow_credentials>
        <allow_headers>header1,header2</allow_headers>
        
        for the `allow_credentials`, if not defined anywhere but there is an `authorize` section defined (here in the API node level, not inside `cors` section, or globally),
        then the app will default `allow_credentials` to true, otherwise it will default to false (we'll discuss the `authorize` section in another example).
        
        And for the `allow_headers`, if not defined anywhere (here or globally), it will default to allowing all headers (i.e., `*`)
        if the `allow_credentials` is set to false, or `authorize` section is not defined (here or globally),
        otherwise if `allow_credentials` is true (or not defined anywhere but `authorize` node exist here or globally), 
        it will default to allowing only the following headers: `Authorization, Content-Type, X-Requested-With, Accept, Origin, X-Api-Key`
        
        And for `max-age`, if not defined anywhere (here or globally), it will default to 86400 seconds (1 day)
        
        And as for other CORS settings such as `allow_methods` (i.e., `Access-Control-Allow-Methods`),
        there is no specific local or global setting for it under `cors` node, 
        but it gets automatically set by the app based on the `verb` defined for the API endpoint.
        and if no `verb` is defined, it will default to allowing all methods (i.e., `GET, POST, PUT, DELETE, OPTIONS, PATCH, HEAD`)
        -->
      </cors>
      <route>cors/hello_world</route>
      <query>
        <![CDATA[
        
        declare @name nvarchar(500) = {{name}};


        if (@name is null or ltrim(rtrim(@name)) = '')
        begin
            set @name = 'world';
        end
        select 
        'hello ' + @name + '! Time now is ' + convert(nvarchar(50), getdate(), 121) as message_from_db;
        
        
        ]]>
      </query>

    </hello_world_cors_example>

    <hello_world_cors>
      <route>cors/hello_world</route>
      <!-- 
      if `cors` not defined here, the system will look for a default cors configuration
      in main settings under files (e.g., settings.xml or cors_settings.xml, etc..)
      under `settings` node, and if not found there
      it will default to allowing all origins (i.e., `*`)
      -->
      <cors>
        <!-- regex pattern for localhost or *.example.com -->
        <pattern><![CDATA[^(localhost|.*\.dfm\.ae)$]]></pattern>
        <!-- 
        fallback_origin: default cors value if the caller's origin domain doesn't match the regex pattern above
        -->
        <fallback_origin><![CDATA[www.example.com]]></fallback_origin>
      </cors>
      <query>
        <![CDATA[
        
        declare @name nvarchar(500) = {{name}};


        if (@name is null or ltrim(rtrim(@name)) = '')
        begin
            set @name = 'world';
        end
        select 
        'hello ' + @name + '! Time now is ' + convert(nvarchar(50), getdate(), 121) as message_from_db;
        
        
        ]]>
      </query>
    </hello_world_cors>


    <hello_world_auth>
      <authorize>
        <provider>azure_b2c</provider>
      </authorize>
      <route>auth/hello_world</route>

      <cors>
        <!-- regex pattern for localhost or *.example.com -->
        <pattern><![CDATA[^(localhost|.*\.dfm\.ae)$]]></pattern>
        <!-- 
        fallback_origin: default cors value if the caller's origin domain doesn't match the regex pattern above
        -->
        <fallback_origin><![CDATA[www.dfm.ae]]></fallback_origin>
      </cors>


      <query>
        <![CDATA[
        
        declare @name nvarchar(500) = {auth{name}};
        -- you can lookup other user info from your user db table using the {auth{email}} or other auth variables
        -- auth variables can be the name of the claim, and if the claim has special characters (e.g., dot), you can use underscore instead
        -- e.g., if the claim is `user.email`, you can access it via {auth{user_email}}
        -- authorization to be done in query by having a user table and checking if the user exist, is active, what roles they have, etc.
        -- if the user is not authorized, you can throw 50401 to return http 401 error, or throw 50403 to return http 403 error


        if (@name is null or ltrim(rtrim(@name)) = '')
        begin
            set @name = 'world';
        end
        select 
        'hello ' + @name + '! Time now is ' + convert(nvarchar(50), getdate(), 121) as message_from_db;
        
        
        ]]>
      </query>
    </hello_world_auth>
    
    
    
    <!-- Multi-Query Chaining -->
    <hello_world_multi_query>
      <!-- Fallback connection string for queries without explicit connection_string_name attribute -->
      <connection_string_name>server2</connection_string_name>

      <!-- Query 1: Uses 'server2' (fallback). Output columns become parameters for Query 2. -->
      <query>
        <![CDATA[select 'new role' as role_from_query1, 'new user' as user_from_query1;]]>
      </query>
      
      <!-- Query 2: Uses 'server3' (explicit). Receives {{role_from_query1}} and {{user_from_query1}} from Query 1. -->
      <query connection_string_name="server3">
        <![CDATA[
              declare @role_from_query1 nvarchar(100) = {{role_from_query1}};
                    SELECT * FROM (VALUES
                        ('Developer', 'Developer'),
                        ('Administrator', 'Administrator'),
                        ('Insiders Admin', 'Insiders Admin'),
                        ('Insiders Maker', 'Insiders Maker'),
                        ('Insiders Checker', 'Insiders Checker'),
                        (@role_from_query1, @role_from_query1)
                        
                ) AS t ([value], [label]);
                
        ]]>
      </query>
      
      <!-- Query 3: Uses 'server2' (fallback). Receives {{json}} array since Query 2 returned multiple rows. -->
      <query>
        <![CDATA[
              declare @roles_json nvarchar(max) = {{json}};
              
              select 
                  JSON_VALUE(value, '$.value') as role_value,
                  JSON_VALUE(value, '$.label') as role_label
              from OPENJSON(@roles_json);
        ]]>
      </query>
      
      <!-- 
      Multi-Query Chaining Documentation:
      See MULTI_QUERY_CHAINING.md for complete documentation.
      -->
      
    </hello_world_multi_query>

    
    <!-- 
    HTTP call example from within sql.
    -->
    <http_call>
      <query>
        <![CDATA[
        
        declare @json nvarchar(max) = {http{
        {
          "url": "https://localhost:5001/hello_world?name={{name}}",
          "method": "GET",
          "headers": {
            "Content-Type": "application/json"
          }
        }
        }http};
        
        -- do something with @json, e.g., return it to the caller or parse it further, etc..
        
        select @json as http_call_response;


        
        
        ]]>
      </query>
    </http_call>


    </queries>

</settings>
